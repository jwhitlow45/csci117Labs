// 1) nested if, nested case
/*
local A B C in 
   A = false
   C = true

   if C then
      skip Browse A
   else
      if B then
         skip Basic
      else
         skip Basic
      end
   end

   case A of tree then
      skip Basic
   else
      case A of false then
         skip Basic
      else
         skip Basic
      end
      case A of true then
         skip Basic
      else
         skip Basic
      end
   end
end


// 2) more expressions; note that applications of primitive binary operators
//    ==, <, >, +, -, *, mod must be enclosed in parentheses (for hoz)

local A B C D B1 B2 in 
   A = 2
   B = 1
   D = 3
   {Eq A B B1}
   if B1 then
      skip Basic
   else
      skip Basic
   end
   {IntMinus D B C}
   {Eq A C B2}
   if B2 then
      skip Browse A
   else
      skip Basic
   end
end



// 3) "in" declaration 

local T X Y in
   T = tree(1:3 2:T)
   X = 5
   Y = 2
   local A B B1 One T in
      tree(1:A 2:B) = T
      One = 1
      {Eq One One B1}
      if B1 then
         local B Z in
            {IntMinus X Y B}
            skip Browse B
         end
      else
         skip Basic
      end
   end   
end
*/

// 4) expressions in place of statements

local Fun R in
   Fun = fun {$ X}     // function returns a value (last item of function)
            X          // returned value
         end
   R = {Fun 4}         // Var = Expression
   skip Browse R
end


// 5) Bind fun

local A B in
   skip Basic
   A = rdc(1:4 2:B 3:(B#B))         // Bind with pattern
   B = (5 + (3 - 4))                // Bind with expression
   skip Browse A
   skip Browse B
   skip Store
end
